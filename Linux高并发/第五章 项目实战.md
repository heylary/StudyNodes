# 第五章 项目实战

## 5.1 阻塞/非阻塞、同步/异步（网络IO）

> 典型的一次IO的两个阶段是什么？ 数据就绪和数据读写

数据就绪：根据系统IO操作的就绪状态 

- 阻塞 
- 非阻塞 

数据读写：根据应用程序和内核的交互方式 

- 同步 
- 异步

I/O 阻塞和非阻塞：**指 I/O 操作是否会阻塞（暂停）程序的执行**。在阻塞 I/O 操作中，程序在等待 I/O 操作完成时会被挂起，无法执行其他操作。相反，在非阻塞 I/O 操作中，程序可以在 I/O 操作进行的同时继续执行其他操作，而无需等待 I/O 操作完成。

同步和异步 I/O：**指 I/O 操作是由调用它们的进程（线程）同步地完成，还是由操作系统异步地完成**。在同步 I/O 操作中，程序会等待 I/O 操作完成，而在异步 I/O 操作中，程序会在 I/O 操作进行的同时继续执行其他操作，而无需等待 I/O 操作完成。

 **在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。**

![img](D:\WorkData\MarkdownData\Linux高并发\assets\77de9cb88ed78aea5921bdeed6550871.png)

![img](D:\WorkData\MarkdownData\Linux高并发\assets\1f38dc72adf8ee9b546e0d149b201321.png)

> 一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。
>
> 同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。

- 同步阻塞
- 同步非阻塞
- 异步阻塞
- 异步非阻塞

## 5.2 Unix、Linux上的五种IO模型

在 Linux 系统中，常见的 I/O 模型主要有以下五种：

1. **阻塞式 I/O（Blocking I/O）**：当应用程序发起一个 I/O 请求时，它会一直等待，直到操作完成。这种方式下，应用程序不能做其他事情。

2. **非阻塞式 I/O（Non-blocking I/O）**：当应用程序发起一个 I/O 请求时，它会立即返回，然后继续执行其他操作。如果 I/O 操作没有完成，应用程序可以继续发起其他操作或者再次尝试该操作。

3. **I/O 多路复用（I/O multiplexing）**：使用 `select`、`poll` 或 `epoll` 等系统调用来监控多个文件描述符上的 I/O 事件，从而避免了阻塞式模型中的等待操作。当某个文件描述符就绪时，应用程序可以执行相应的 I/O 操作。

4. **信号驱动式 I/O（Signal driven I/O）**：应用程序向内核注册一个信号处理函数，并告诉内核在某个文件描述符上发生 I/O 事件时发送一个特定的信号。当内核检测到该文件描述符上的事件时，它会自动向应用程序发送相应的信号，触发信号处理函数来处理 I/O 事件。

5. **异步 I/O（Asynchronous I/O）**：应用程序发起 I/O 请求后立即返回，然后内核负责处理该请求并将结果写回给应用程序。这种方式下，应用程序不需要等待 I/O 操作完成，也不需要等待内核通知其何时能够读取数据。相反，内核会在数据准备好时通知应用程序进行读取操作。

   

1. 阻塞 blocking：调用者调用了某个函数，等待这个函数返回，**期间什么也不做**，不停的去检查这个函数有没有返回，**必须等这个函数返回才能进行下一步动作**。

![img](D:\WorkData\MarkdownData\Linux高并发\assets\ef2d2d74610e55fd437b9a9b70e69f95.png)

2. 非阻塞 non-blocking（NIO）：非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。

![img](D:\WorkData\MarkdownData\Linux高并发\assets\be0e70b27d6f545da0866ed3cc3a6652.png)

3. IO复用（IO multiplexing）：Linux 用 select/poll/epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数。

![img](D:\WorkData\MarkdownData\Linux高并发\assets\61c5250378162d876bef57d5391d923d.png)

4. 信号驱动（signal-driven）：Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。

![img](D:\WorkData\MarkdownData\Linux高并发\assets\630f0dd2bb69579c25a38be4f062745b.png)

> 内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。

5. 异步（asynchronous）：Linux中，**可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回**，当内核将数据拷贝到缓冲区后，再通知应用程序。

![img](D:\WorkData\MarkdownData\Linux高并发\assets\e7a5aacfb28fec4b4f5fdd9519d14863.png)

## 5.3 Web服务器简介及HTTP协议

### 1. Web服务器

一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是**通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信**，来**接收，存储，处理来自客户端的 HTTP 请求**，**并对其请求做出 HTTP 响应**，返回给客户端其请求的内容（文件、网页等）或返回一个 Error 信息。

![img](D:\WorkData\MarkdownData\Linux高并发\assets\143214e26cad65249a276abd17917e8c.png)

通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。

### 2. HTTP协议（应用层协议）简介

- 超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。**请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。**HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering TaskForce，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。
- HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。
- 尽管 TCP/IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP/IP 协议族使用 TCP 作为其传
  输层。
- 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

### 3. HTTP工作原理

HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，**请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。**

![img](D:\WorkData\MarkdownData\Linux高并发\assets\29e38f3d92afb9cc503746d2912f07bf.png)

![img](D:\WorkData\MarkdownData\Linux高并发\assets\814f32366556d2a6bcd4b6f304b6e834.png)

### 4. HTTP 请求报文格式

![img](D:\WorkData\MarkdownData\Linux高并发\assets\fa7ab1900f139afa1b59966f73e31110.png)

### 5. HTTP响应报文格式

![img](D:\WorkData\MarkdownData\Linux高并发\assets\d7beb0de25e2b123dcc5da2548e38dcb.png)

## 5.4 服务器编程基本框架

1. **虽然服务器程序种类繁多，但其基本框架都一样**，不同之处在于逻辑处理。
2. 模块

![img](D:\WorkData\MarkdownData\Linux高并发\assets\eb871452678bd6c90aa39ed8cb00ca4e.png)

- I/O 处理单元是服务器管理客户连接的模块。它通常要完成以下工作：**等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端**。但是数据的收发不一定在 I/O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。

- 一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I/O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。

- 网络存储单元可以是数据库、缓存和文件，但不是必须的。

- 请求队列是各单元之间的通信方式的抽象。I/O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。

  

## 5.5 两种高效的事件处理模式

> 服务器程序通常需要处理三类事件：**I/O 事件、信号及定时事件**。
>
> 有两种高效的事件处理模式：Reactor和 Proactor，**同步 I/O 模型通常用于实现 Reactor 模式，**异步 I/O 模型通常用于实现 Proactor 模式。

- **Reactor模式**

  - 要求主线程（I/O处理单元）**只负责监听文件描述符上是否有事件发生**，有的话就立即将该事件通知工作线程（逻辑单元），将 socket 可读可写事件放入请求队列，**交给工作线程处理**。除此之外，主线程不做任何其他实质性的工作。**读写数据，接受新的连接，以及处理客户请求均在工作线程中完成**。

  - 使用同步 I/O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：
    - 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。
    - 主线程调用 epoll_wait 等待 socket 上有数据可读。
    - 当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。
    - 睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll内核事件表中注册 该 socket 上的写就绪事件。
    - 当主线程调用 epoll_wait 等待 socket 可写。
    - 当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。
    - 睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。

![img](D:\WorkData\MarkdownData\Linux高并发\assets\d1fb941a99736449500c4f656657f5c3.png)

- **Proactor模式** 
  -  Proactor 模式将**所有 I/O 操作都交给主线程和内核**来处理（进行读、写），**工作线程仅仅负责业务逻辑**。使用异步 I/O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：
    - 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。
    - 主线程继续处理其他逻辑。
    - 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。
    - 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何Z通知应用程序。
    - 主线程继续处理其他逻辑。
    - 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。
    - 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。

![img](D:\WorkData\MarkdownData\Linux高并发\assets\617cb9fc9862cec359c52277ebe03cf5.png)

## 5.6 线程同步机制类封装及线程池实现

1. 线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式：
   - 主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。
   - 主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。

2. 线程池的一般模型

   ![img](D:\WorkData\MarkdownData\Linux高并发\assets\7b82b5011012cdb776b0e8ee0b18f533.png)

3. 线程池的数量

   - 线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费

4. 线程池的特点

   - **空间换时间**，浪费服务器的硬件资源，换取运行效率。
   - 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为**静态资源**。
   - 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，**无需动态分配**。
   - 当服务器处理完一个客户连接后，**可以把相关的资源放回池中，无需执行系统调用释放资源**。

5. 代码

- locker.h

```c
#ifndef LOCKER_H
#define LOCKER_H

#include <exception>
#include <pthread.h>
#include <semaphore.h>

// 线程同步机制封装类

// 互斥锁类
class locker {
public:
    locker() {
        if(pthread_mutex_init(&m_mutex, NULL) != 0) {
            throw std::exception();
        }
    }

    ~locker() {
        pthread_mutex_destroy(&m_mutex);
    }

    bool lock() {
        return pthread_mutex_lock(&m_mutex) == 0;
    }

    bool unlock() {
        return pthread_mutex_unlock(&m_mutex) == 0;
    }

    pthread_mutex_t *get()
    {
        return &m_mutex;
    }

private:
    pthread_mutex_t m_mutex;
};


// 条件变量类
class cond {
public:
    cond(){
        if (pthread_cond_init(&m_cond, NULL) != 0) {
            throw std::exception();
        }
    }
    ~cond() {
        pthread_cond_destroy(&m_cond);
    }

    bool wait(pthread_mutex_t *m_mutex) {
        int ret = 0;
        ret = pthread_cond_wait(&m_cond, m_mutex);
        return ret == 0;
    }
    bool timewait(pthread_mutex_t *m_mutex, struct timespec t) {
        int ret = 0;
        ret = pthread_cond_timedwait(&m_cond, m_mutex, &t);
        return ret == 0;
    }
    bool signal() {
        return pthread_cond_signal(&m_cond) == 0;
    }
    bool broadcast() {
        return pthread_cond_broadcast(&m_cond) == 0;
    }

private:
    pthread_cond_t m_cond;
};


// 信号量类
class sem {
public:
    sem() {
        if( sem_init( &m_sem, 0, 0 ) != 0 ) {
            throw std::exception();
        }
    }
    sem(int num) {
        if( sem_init( &m_sem, 0, num ) != 0 ) {
            throw std::exception();
        }
    }
    ~sem() {
        sem_destroy( &m_sem );
    }
    // 等待信号量
    bool wait() {
        return sem_wait( &m_sem ) == 0;
    }
    // 增加信号量
    bool post() {
        return sem_post( &m_sem ) == 0;
    }
private:
    sem_t m_sem;
};

#endif
```

- threadpool.h

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <queue>

template<typename T>
class ThreadPool {
public:
    ThreadPool(int thread_num = 10, int max_task_num = 1000); // 构造函数
    ~ThreadPool(); // 析构函数
    bool AddTask(T task); // 添加任务到任务队列中
    bool StopAll(); // 停止线程池中所有线程的运行
private:
    static void* RunThread(void* arg); // 线程函数，用于执行任务
    T GetTask(); // 获取任务队列中的任务
    int m_thread_num; // 线程数目
    int m_max_task_num; // 任务队列最大长度
    pthread_t* m_threads; // 线程数组
    std::queue<T> m_task_queue; // 任务队列
    pthread_mutex_t m_mutex; // 互斥锁
    pthread_cond_t m_cond; // 条件变量
    bool is_running; // 标识线程池是否在运行
};

// 线程池的构造函数：初始化线程池相关的成员变量，创建线程并将其分离。
template<typename T>
ThreadPool<T>::ThreadPool(int thread_num, int max_task_num) : m_thread_num(thread_num), 
                                                              m_max_task_num(max_task_num),
                                                              is_running(true) {
    m_threads = new pthread_t[m_thread_num];
    if (!m_threads) {
        printf("Failed to allocate memory for threads\n");
        exit(1);
    }
    if (pthread_mutex_init(&m_mutex, NULL) != 0) {
        printf("Failed to initialize mutex\n");
        exit(1);
    }
    if (pthread_cond_init(&m_cond, NULL) != 0) {
        printf("Failed to initialize condition variable\n");
        exit(1);
    }
    for (int i = 0; i < m_thread_num; ++i) {
        if (pthread_create(&m_threads[i], NULL, RunThread, this) != 0) {
            printf("Failed to create threads\n");
            exit(1);
        }
        if (pthread_detach(m_threads[i]) != 0) {
            printf("Failed to detach threads\n");
            exit(1);
        }
    }
}

// 线程池的析构函数：停止线程池的运行，释放内存。
template<typename T>
ThreadPool<T>::~ThreadPool() {
    StopAll();
    delete[] m_threads;
    pthread_mutex_destroy(&m_mutex);
    pthread_cond_destroy(&m_cond);
}

// 添加任务到任务队列中：加锁，判断队列长度是否超过最大值，若未超过则添加任务到队列中，解锁，发信号通知线程有新任务。
template<typename T>
bool ThreadPool<T>::AddTask(T task) {
    pthread_mutex_lock(&m_mutex);
    if (m_task_queue.size() >= m_max_task_num) {
        pthread_mutex_unlock(&m_mutex);
        return false;
    }
    m_task_queue.push(task);
    pthread_cond_signal(&m_cond);
    pthread_mutex_unlock(&m_mutex);
    return true;
}

// 停止线程池中所有线程的运行：修改标志位，发信号通知所有线程。
template<typename T>
bool ThreadPool<T>::StopAll() {
    is_running = false;
    pthread_cond_broadcast(&m_cond);
    return true;
}

// 线程函数：从任务队列中取出任务，并执行。
template<typename T>
void* ThreadPool<T>::RunThread(void* arg) {
    ThreadPool* pool = (ThreadPool*)arg;
    while (pool->is_running) {
        T task = pool->GetTask();
        if (!task) {
            continue;
        }
        task(); // 执行任务
    }
    return NULL;
}

// 获取任务队列中的任务：加锁，若队列为空且线程池仍在运行，则等待信号唤醒；否则，返回队头任务并弹出，解锁。
template<typename T>
T ThreadPool<T>::GetTask() {
    pthread_mutex_lock(&m_mutex);
    while (m_task_queue.empty() && is_running) {
        pthread_cond_wait(&m_cond, &m_mutex);
    }
    T task;
    if (!m_task_queue.empty()) {
        task = m_task_queue.front();
        m_task_queue.pop();
        }
        pthread_mutex_unlock(&m_mutex);
        return task;
    }

```

## 5.7 项目整体流程代码实现

- mian.cpp

```c++
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include "locker.h"
#include "threadpool.h"
#include "http_conn.h"

#define MAX_FD 65536   // 最大的文件描述符个数
#define MAX_EVENT_NUMBER 10000  // 监听的最大的事件数量

// 添加文件描述符
extern void addfd( int epollfd, int fd, bool one_shot );
extern void removefd( int epollfd, int fd );

void addsig(int sig, void( handler )(int)){
    struct sigaction sa;
    memset( &sa, '\0', sizeof( sa ) );
    sa.sa_handler = handler;
    sigfillset( &sa.sa_mask );
    assert( sigaction( sig, &sa, NULL ) != -1 );
}

int main( int argc, char* argv[] ) {
    
    if( argc <= 1 ) {
        printf( "usage: %s port_number\n", basename(argv[0]));
        return 1;
    }

    int port = atoi( argv[1] );
    addsig( SIGPIPE, SIG_IGN );

    threadpool< http_conn >* pool = NULL;
    try {
        pool = new threadpool<http_conn>;
    } catch( ... ) {
        return 1;
    }

    http_conn* users = new http_conn[ MAX_FD ];

    int listenfd = socket( PF_INET, SOCK_STREAM, 0 );

    int ret = 0;
    struct sockaddr_in address;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_family = AF_INET;
    address.sin_port = htons( port );

    // 端口复用
    int reuse = 1;
    setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof( reuse ) );
    ret = bind( listenfd, ( struct sockaddr* )&address, sizeof( address ) );
    ret = listen( listenfd, 5 );

    // 创建epoll对象，和事件数组，添加
    epoll_event events[ MAX_EVENT_NUMBER ];
    int epollfd = epoll_create( 5 );
    // 添加到epoll对象中
    addfd( epollfd, listenfd, false );
    http_conn::m_epollfd = epollfd;

    while(true) {
        
        int number = epoll_wait( epollfd, events, MAX_EVENT_NUMBER, -1 );
        
        if ( ( number < 0 ) && ( errno != EINTR ) ) {
            printf( "epoll failure\n" );
            break;
        }

        for ( int i = 0; i < number; i++ ) {
            
            int sockfd = events[i].data.fd;
            
            if( sockfd == listenfd ) {
                
                struct sockaddr_in client_address;
                socklen_t client_addrlength = sizeof( client_address );
                int connfd = accept( listenfd, ( struct sockaddr* )&client_address, &client_addrlength );
                
                if ( connfd < 0 ) {
                    printf( "errno is: %d\n", errno );
                    continue;
                } 

                if( http_conn::m_user_count >= MAX_FD ) {
                    close(connfd);
                    continue;
                }
                users[connfd].init( connfd, client_address);

            } else if( events[i].events & ( EPOLLRDHUP | EPOLLHUP | EPOLLERR ) ) {

                users[sockfd].close_conn();

            } else if(events[i].events & EPOLLIN) {

                if(users[sockfd].read()) {
                    pool->append(users + sockfd);
                } else {
                    users[sockfd].close_conn();
                }

            }  else if( events[i].events & EPOLLOUT ) {

                if( !users[sockfd].write() ) {
                    users[sockfd].close_conn();
                }

            }
        }
    }
    
    close( epollfd );
    close( listenfd );
    delete [] users;
    delete pool;
    return 0;
}

```

- http_conn.h

  ```c++
  #ifndef HTTPCONNECTION_H
  #define HTTPCONNECTION_H
  
  #include <unistd.h>
  #include <signal.h>
  #include <sys/types.h>
  #include <sys/epoll.h>
  #include <fcntl.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>
  #include <assert.h>
  #include <sys/stat.h>
  #include <string.h>
  #include <pthread.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <sys/mman.h>
  #include <stdarg.h>
  #include <errno.h>
  #include "locker.h"
  #include <sys/uio.h>
  
  class http_conn
  {
  public:
      static const int FILENAME_LEN = 200;        // 文件名的最大长度
      static const int READ_BUFFER_SIZE = 2048;   // 读缓冲区的大小
      static const int WRITE_BUFFER_SIZE = 1024;  // 写缓冲区的大小
      
      // HTTP请求方法，这里只支持GET
      enum METHOD {GET = 0, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT};
      
      /*
          解析客户端请求时，主状态机的状态
          CHECK_STATE_REQUESTLINE:当前正在分析请求行
          CHECK_STATE_HEADER:当前正在分析头部字段
          CHECK_STATE_CONTENT:当前正在解析请求体
      */
      enum CHECK_STATE { CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER, CHECK_STATE_CONTENT };
      
      /*
          服务器处理HTTP请求的可能结果，报文解析的结果
          NO_REQUEST          :   请求不完整，需要继续读取客户数据
          GET_REQUEST         :   表示获得了一个完成的客户请求
          BAD_REQUEST         :   表示客户请求语法错误
          NO_RESOURCE         :   表示服务器没有资源
          FORBIDDEN_REQUEST   :   表示客户对资源没有足够的访问权限
          FILE_REQUEST        :   文件请求,获取文件成功
          INTERNAL_ERROR      :   表示服务器内部错误
          CLOSED_CONNECTION   :   表示客户端已经关闭连接了
      */
      enum HTTP_CODE { NO_REQUEST, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION };
      
      // 从状态机的三种可能状态，即行的读取状态，分别表示
      // 1.读取到一个完整的行 2.行出错 3.行数据尚且不完整
      enum LINE_STATUS { LINE_OK = 0, LINE_BAD, LINE_OPEN };
  public:
      http_conn(){}
      ~http_conn(){}
  public:
      void init(int sockfd, const sockaddr_in& addr); // 初始化新接受的连接
      void close_conn();  // 关闭连接
      void process(); // 处理客户端请求
      bool read();// 非阻塞读
      bool write();// 非阻塞写
  private:
      void init();    // 初始化连接
      HTTP_CODE process_read();    // 解析HTTP请求
      bool process_write( HTTP_CODE ret );    // 填充HTTP应答
  
      // 下面这一组函数被process_read调用以分析HTTP请求
      HTTP_CODE parse_request_line( char* text );
      HTTP_CODE parse_headers( char* text );
      HTTP_CODE parse_content( char* text );
      HTTP_CODE do_request();
      char* get_line() { return m_read_buf + m_start_line; }
      LINE_STATUS parse_line();
  
      // 这一组函数被process_write调用以填充HTTP应答。
      void unmap();
      bool add_response( const char* format, ... );
      bool add_content( const char* content );
      bool add_content_type();
      bool add_status_line( int status, const char* title );
      bool add_headers( int content_length );
      bool add_content_length( int content_length );
      bool add_linger();
      bool add_blank_line();
  
  public:
      static int m_epollfd;       // 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的
      static int m_user_count;    // 统计用户的数量
  
  private:
      int m_sockfd;           // 该HTTP连接的socket和对方的socket地址
      sockaddr_in m_address;
      
      char m_read_buf[ READ_BUFFER_SIZE ];    // 读缓冲区
      int m_read_idx;                         // 标识读缓冲区中已经读入的客户端数据的最后一个字节的下一个位置
      int m_checked_idx;                      // 当前正在分析的字符在读缓冲区中的位置
      int m_start_line;                       // 当前正在解析的行的起始位置
  
      CHECK_STATE m_check_state;              // 主状态机当前所处的状态
      METHOD m_method;                        // 请求方法
  
      char m_real_file[ FILENAME_LEN ];       // 客户请求的目标文件的完整路径，其内容等于 doc_root + m_url, doc_root是网站根目录
      char* m_url;                            // 客户请求的目标文件的文件名
      char* m_version;                        // HTTP协议版本号，我们仅支持HTTP1.1
      char* m_host;                           // 主机名
      int m_content_length;                   // HTTP请求的消息总长度
      bool m_linger;                          // HTTP请求是否要求保持连接
  
      char m_write_buf[ WRITE_BUFFER_SIZE ];  // 写缓冲区
      int m_write_idx;                        // 写缓冲区中待发送的字节数
      char* m_file_address;                   // 客户请求的目标文件被mmap到内存中的起始位置
      struct stat m_file_stat;                // 目标文件的状态。通过它我们可以判断文件是否存在、是否为目录、是否可读，并获取文件大小等信息
      struct iovec m_iv[2];                   // 我们将采用writev来执行写操作，所以定义下面两个成员，其中m_iv_count表示被写内存块的数量。
      int m_iv_count;
  };
  
  #endif
  
  
  ```

- http_conn.cpp

  ```c++
  #include "http_conn.h"
  
  // 定义HTTP响应的一些状态信息
  const char* ok_200_title = "OK";
  const char* error_400_title = "Bad Request";
  const char* error_400_form = "Your request has bad syntax or is inherently impossible to satisfy.\n";
  const char* error_403_title = "Forbidden";
  const char* error_403_form = "You do not have permission to get file from this server.\n";
  const char* error_404_title = "Not Found";
  const char* error_404_form = "The requested file was not found on this server.\n";
  const char* error_500_title = "Internal Error";
  const char* error_500_form = "There was an unusual problem serving the requested file.\n";
  
  // 网站的根目录
  const char* doc_root = "/home/nowcoder/webserver/resources";
  
  int setnonblocking( int fd ) {
      int old_option = fcntl( fd, F_GETFL );
      int new_option = old_option | O_NONBLOCK;
      fcntl( fd, F_SETFL, new_option );
      return old_option;
  }
  
  // 向epoll中添加需要监听的文件描述符
  void addfd( int epollfd, int fd, bool one_shot ) {
      epoll_event event;
      event.data.fd = fd;
      event.events = EPOLLIN | EPOLLRDHUP;
      if(one_shot) 
      {
          // 防止同一个通信被不同的线程处理
          event.events |= EPOLLONESHOT;
      }
      epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event);
      // 设置文件描述符非阻塞
      setnonblocking(fd);  
  }
  
  // 从epoll中移除监听的文件描述符
  void removefd( int epollfd, int fd ) {
      epoll_ctl( epollfd, EPOLL_CTL_DEL, fd, 0 );
      close(fd);
  }
  
  // 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发
  void modfd(int epollfd, int fd, int ev) {
      epoll_event event;
      event.data.fd = fd;
      event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;
      epoll_ctl( epollfd, EPOLL_CTL_MOD, fd, &event );
  }
  
  // 所有的客户数
  int http_conn::m_user_count = 0;
  // 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的
  int http_conn::m_epollfd = -1;
  
  // 关闭连接
  void http_conn::close_conn() {
      if(m_sockfd != -1) {
          removefd(m_epollfd, m_sockfd);
          m_sockfd = -1;
          m_user_count--; // 关闭一个连接，将客户总数量-1
      }
  }
  
  // 初始化连接,外部调用初始化套接字地址
  void http_conn::init(int sockfd, const sockaddr_in& addr){
      m_sockfd = sockfd;
      m_address = addr;
      
      // 端口复用
      int reuse = 1;
      setsockopt( m_sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof( reuse ) );
      addfd( m_epollfd, sockfd, true );
      m_user_count++;
      init();
  }
  
  void http_conn::init()
  {
      m_check_state = CHECK_STATE_REQUESTLINE;    // 初始状态为检查请求行
      m_linger = false;       // 默认不保持链接  Connection : keep-alive保持连接
  
      m_method = GET;         // 默认请求方式为GET
      m_url = 0;              
      m_version = 0;
      m_content_length = 0;
      m_host = 0;
      m_start_line = 0;
      m_checked_idx = 0;
      m_read_idx = 0;
      m_write_idx = 0;
      bzero(m_read_buf, READ_BUFFER_SIZE);
      bzero(m_write_buf, READ_BUFFER_SIZE);
      bzero(m_real_file, FILENAME_LEN);
  }
  
  // 循环读取客户数据，直到无数据可读或者对方关闭连接
  bool http_conn::read() {
      if( m_read_idx >= READ_BUFFER_SIZE ) {
          return false;
      }
      int bytes_read = 0;
      while(true) {
          // 从m_read_buf + m_read_idx索引出开始保存数据，大小是READ_BUFFER_SIZE - m_read_idx
          bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, 
          READ_BUFFER_SIZE - m_read_idx, 0 );
          if (bytes_read == -1) {
              if( errno == EAGAIN || errno == EWOULDBLOCK ) {
                  // 没有数据
                  break;
              }
              return false;   
          } else if (bytes_read == 0) {   // 对方关闭连接
              return false;
          }
          m_read_idx += bytes_read;
      }
      return true;
  }
  
  // 解析一行，判断依据\r\n
  http_conn::LINE_STATUS http_conn::parse_line() {
      char temp;
      for ( ; m_checked_idx < m_read_idx; ++m_checked_idx ) {
          temp = m_read_buf[ m_checked_idx ];
          if ( temp == '\r' ) {
              if ( ( m_checked_idx + 1 ) == m_read_idx ) {
                  return LINE_OPEN;
              } else if ( m_read_buf[ m_checked_idx + 1 ] == '\n' ) {
                  m_read_buf[ m_checked_idx++ ] = '\0';
                  m_read_buf[ m_checked_idx++ ] = '\0';
                  return LINE_OK;
              }
              return LINE_BAD;
          } else if( temp == '\n' )  {
              if( ( m_checked_idx > 1) && ( m_read_buf[ m_checked_idx - 1 ] == '\r' ) ) {
                  m_read_buf[ m_checked_idx-1 ] = '\0';
                  m_read_buf[ m_checked_idx++ ] = '\0';
                  return LINE_OK;
              }
              return LINE_BAD;
          }
      }
      return LINE_OPEN;
  }
  
  // 解析HTTP请求行，获得请求方法，目标URL,以及HTTP版本号
  http_conn::HTTP_CODE http_conn::parse_request_line(char* text) {
      // GET /index.html HTTP/1.1
      m_url = strpbrk(text, " \t"); // 判断第二个参数中的字符哪个在text中最先出现
      if (! m_url) { 
          return BAD_REQUEST;
      }
      // GET\0/index.html HTTP/1.1
      *m_url++ = '\0';    // 置位空字符，字符串结束符
      char* method = text;
      if ( strcasecmp(method, "GET") == 0 ) { // 忽略大小写比较
          m_method = GET;
      } else {
          return BAD_REQUEST;
      }
      // /index.html HTTP/1.1
      // 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。
      m_version = strpbrk( m_url, " \t" );
      if (!m_version) {
          return BAD_REQUEST;
      }
      *m_version++ = '\0';
      if (strcasecmp( m_version, "HTTP/1.1") != 0 ) {
          return BAD_REQUEST;
      }
      /**
       * http://192.168.110.129:10000/index.html
      */
      if (strncasecmp(m_url, "http://", 7) == 0 ) {   
          m_url += 7;
          // 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。
          m_url = strchr( m_url, '/' );
      }
      if ( !m_url || m_url[0] != '/' ) {
          return BAD_REQUEST;
      }
      m_check_state = CHECK_STATE_HEADER; // 检查状态变成检查头
      return NO_REQUEST;
  }
  
  // 解析HTTP请求的一个头部信息
  http_conn::HTTP_CODE http_conn::parse_headers(char* text) {   
      // 遇到空行，表示头部字段解析完毕
      if( text[0] == '\0' ) {
          // 如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，
          // 状态机转移到CHECK_STATE_CONTENT状态
          if ( m_content_length != 0 ) {
              m_check_state = CHECK_STATE_CONTENT;
              return NO_REQUEST;
          }
          // 否则说明我们已经得到了一个完整的HTTP请求
          return GET_REQUEST;
      } else if ( strncasecmp( text, "Connection:", 11 ) == 0 ) {
          // 处理Connection 头部字段  Connection: keep-alive
          text += 11;
          text += strspn( text, " \t" );
          if ( strcasecmp( text, "keep-alive" ) == 0 ) {
              m_linger = true;
          }
      } else if ( strncasecmp( text, "Content-Length:", 15 ) == 0 ) {
          // 处理Content-Length头部字段
          text += 15;
          text += strspn( text, " \t" );
          m_content_length = atol(text);
      } else if ( strncasecmp( text, "Host:", 5 ) == 0 ) {
          // 处理Host头部字段
          text += 5;
          text += strspn( text, " \t" );
          m_host = text;
      } else {
          printf( "oop! unknow header %s\n", text );
      }
      return NO_REQUEST;
  }
  
  // 我们没有真正解析HTTP请求的消息体，只是判断它是否被完整的读入了
  http_conn::HTTP_CODE http_conn::parse_content( char* text ) {
      if ( m_read_idx >= ( m_content_length + m_checked_idx ) )
      {
          text[ m_content_length ] = '\0';
          return GET_REQUEST;
      }
      return NO_REQUEST;
  }
  
  // 主状态机，解析请求
  http_conn::HTTP_CODE http_conn::process_read() {
      LINE_STATUS line_status = LINE_OK;
      HTTP_CODE ret = NO_REQUEST;
      char* text = 0;
      while (((m_check_state == CHECK_STATE_CONTENT) && (line_status == LINE_OK))
                  || ((line_status = parse_line()) == LINE_OK)) {
          // 获取一行数据
          text = get_line();
          m_start_line = m_checked_idx;
          printf( "got 1 http line: %s\n", text );
  
          switch ( m_check_state ) {
              case CHECK_STATE_REQUESTLINE: {
                  ret = parse_request_line( text );
                  if ( ret == BAD_REQUEST ) {
                      return BAD_REQUEST;
                  }
                  break;
              }
              case CHECK_STATE_HEADER: {
                  ret = parse_headers( text );
                  if ( ret == BAD_REQUEST ) {
                      return BAD_REQUEST;
                  } else if ( ret == GET_REQUEST ) {
                      return do_request();
                  }
                  break;
              }
              case CHECK_STATE_CONTENT: {
                  ret = parse_content( text );
                  if ( ret == GET_REQUEST ) {
                      return do_request();
                  }
                  line_status = LINE_OPEN;
                  break;
              }
              default: {
                  return INTERNAL_ERROR;
              }
          }
      }
      return NO_REQUEST;
  }
  
  // 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，
  // 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其
  // 映射到内存地址m_file_address处，并告诉调用者获取文件成功
  http_conn::HTTP_CODE http_conn::do_request()
  {
      // "/home/nowcoder/webserver/resources"
      strcpy( m_real_file, doc_root );
      int len = strlen( doc_root );
      strncpy( m_real_file + len, m_url, FILENAME_LEN - len - 1 );
      // 获取m_real_file文件的相关的状态信息，-1失败，0成功
      if ( stat( m_real_file, &m_file_stat ) < 0 ) {
          return NO_RESOURCE;
      }
  
      // 判断访问权限
      if ( ! ( m_file_stat.st_mode & S_IROTH ) ) {
          return FORBIDDEN_REQUEST;
      }
  
      // 判断是否是目录
      if ( S_ISDIR( m_file_stat.st_mode ) ) {
          return BAD_REQUEST;
      }
  
      // 以只读方式打开文件
      int fd = open( m_real_file, O_RDONLY );
      // 创建内存映射
      m_file_address = ( char* )mmap( 0, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0 );
      close( fd );
      return FILE_REQUEST;
  }
  
  // 对内存映射区执行munmap操作
  void http_conn::unmap() {
      if( m_file_address )
      {
          munmap( m_file_address, m_file_stat.st_size );
          m_file_address = 0;
      }
  }
  
  // 写HTTP响应
  bool http_conn::write()
  {
      int temp = 0;
      int bytes_have_send = 0;    // 已经发送的字节
      int bytes_to_send = m_write_idx;// 将要发送的字节 （m_write_idx）写缓冲区中待发送的字节数
      
      if ( bytes_to_send == 0 ) {
          // 将要发送的字节为0，这一次响应结束。
          modfd( m_epollfd, m_sockfd, EPOLLIN ); 
          init();
          return true;
      }
  
      while(1) {
          // 分散写
          temp = writev(m_sockfd, m_iv, m_iv_count);
          if ( temp <= -1 ) {
              // 如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件，虽然在此期间，
              // 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性。
              if( errno == EAGAIN ) {
                  modfd( m_epollfd, m_sockfd, EPOLLOUT );
                  return true;
              }
              unmap();
              return false;
          }
          bytes_to_send -= temp;
          bytes_have_send += temp;
          if ( bytes_to_send <= bytes_have_send ) {
              // 发送HTTP响应成功，根据HTTP请求中的Connection字段决定是否立即关闭连接
              unmap();
              if(m_linger) {
                  init();
                  modfd( m_epollfd, m_sockfd, EPOLLIN );
                  return true;
              } else {
                  modfd( m_epollfd, m_sockfd, EPOLLIN );
                  return false;
              } 
          }
      }
  }
  
  // 往写缓冲中写入待发送的数据
  bool http_conn::add_response( const char* format, ... ) {
      if( m_write_idx >= WRITE_BUFFER_SIZE ) {
          return false;
      }
      va_list arg_list;
      va_start( arg_list, format );
      int len = vsnprintf( m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - 1 - m_write_idx, format, arg_list );
      if( len >= ( WRITE_BUFFER_SIZE - 1 - m_write_idx ) ) {
          return false;
      }
      m_write_idx += len;
      va_end( arg_list );
      return true;
  }
  
  bool http_conn::add_status_line( int status, const char* title ) {
      return add_response( "%s %d %s\r\n", "HTTP/1.1", status, title );
  }
  
  bool http_conn::add_headers(int content_len) {
      add_content_length(content_len);
      add_content_type();
      add_linger();
      add_blank_line();
  }
  
  bool http_conn::add_content_length(int content_len) {
      return add_response( "Content-Length: %d\r\n", content_len );
  }
  
  bool http_conn::add_linger()
  {
      return add_response( "Connection: %s\r\n", ( m_linger == true ) ? "keep-alive" : "close" );
  }
  
  bool http_conn::add_blank_line()
  {
      return add_response( "%s", "\r\n" );
  }
  
  bool http_conn::add_content( const char* content )
  {
      return add_response( "%s", content );
  }
  
  bool http_conn::add_content_type() {
      return add_response("Content-Type:%s\r\n", "text/html");
  }
  
  // 根据服务器处理HTTP请求的结果，决定返回给客户端的内容
  bool http_conn::process_write(HTTP_CODE ret) {
      switch (ret)
      {
          case INTERNAL_ERROR:
              add_status_line( 500, error_500_title );
              add_headers( strlen( error_500_form ) );
              if ( ! add_content( error_500_form ) ) {
                  return false;
              }
              break;
          case BAD_REQUEST:
              add_status_line( 400, error_400_title );
              add_headers( strlen( error_400_form ) );
              if ( ! add_content( error_400_form ) ) {
                  return false;
              }
              break;
          case NO_RESOURCE:
              add_status_line( 404, error_404_title );
              add_headers( strlen( error_404_form ) );
              if ( ! add_content( error_404_form ) ) {
                  return false;
              }
              break;
          case FORBIDDEN_REQUEST:
              add_status_line( 403, error_403_title );
              add_headers(strlen( error_403_form));
              if ( ! add_content( error_403_form ) ) {
                  return false;
              }
              break;
          case FILE_REQUEST:
              add_status_line(200, ok_200_title );
              add_headers(m_file_stat.st_size);
              m_iv[ 0 ].iov_base = m_write_buf;
              m_iv[ 0 ].iov_len = m_write_idx;
              m_iv[ 1 ].iov_base = m_file_address;
              m_iv[ 1 ].iov_len = m_file_stat.st_size;
              m_iv_count = 2;
              return true;
          default:
              return false;
      }
  
      m_iv[ 0 ].iov_base = m_write_buf;
      m_iv[ 0 ].iov_len = m_write_idx;
      m_iv_count = 1;
      return true;
  }
  
  // 由线程池中的工作线程调用，这是处理HTTP请求的入口函数
  void http_conn::process() {
      // 解析HTTP请求
      HTTP_CODE read_ret = process_read();
      if ( read_ret == NO_REQUEST ) {
          modfd( m_epollfd, m_sockfd, EPOLLIN );
          return;
      }
      
      // 生成响应
      bool write_ret = process_write( read_ret );
      if ( !write_ret ) {
          close_conn();
      }
      modfd( m_epollfd, m_sockfd, EPOLLOUT);
  }
  
  ```

  > EPOLLONESHOT事件
  >
  > - 即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。
  > - 对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。

## 5.8 解析HTTP请求报文

1. 有限状态机：逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：

```c++
STATE_MACHINE( Package _pack )
{
	PackageType _type = _pack.GetType();
	switch( _type )
	{
		case type_A:
			process_package_A( _pack );
			break;
		case type_B:
			process_package_B( _pack );
			break;
	}
}
// 上面是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。

```

2. 状态之间的转移是需要状态机内部驱动，如下代码：

```c++
STATE_MACHINE()
{
	State cur_State = type_A;
	while( cur_State != type_C )
	{
		Package _pack = getNewPackage();
		switch( cur_State )
		{
			case type_A:
                process_package_state_A( _pack );
                cur_State = type_B;
                break;
			case type_B:
                process_package_state_B( _pack );
                cur_State = type_C;
                break;
		}		
	}
}

// 该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。

```

## 5.9

- noactive-lst_timer.h

  ```c++
  #ifndef LST_TIMER
  #define LST_TIMER
  
  #include <stdio.h>
  #include <time.h>
  #include <arpa/inet.h>
  
  #define BUFFER_SIZE 64
  class util_timer;   // 前向声明
  
  // 用户数据结构
  struct client_data
  {
      sockaddr_in address;    // 客户端socket地址
      int sockfd;             // socket文件描述符
      char buf[ BUFFER_SIZE ];    // 读缓存
      util_timer* timer;          // 定时器
  };
  
  // 定时器类
  class util_timer {
  public:
      util_timer() : prev(NULL), next(NULL){}
  
  public:
     time_t expire;   // 任务超时时间，这里使用绝对时间
     void (*cb_func)( client_data* ); // 任务回调函数，回调函数处理的客户数据，由定时器的执行者传递给回调函数
     client_data* user_data; 
     util_timer* prev;    // 指向前一个定时器
     util_timer* next;    // 指向后一个定时器
  };
  
  // 定时器链表，它是一个升序、双向链表，且带有头节点和尾节点。
  class sort_timer_lst {
  public:
      sort_timer_lst() : head( NULL ), tail( NULL ) {}
      // 链表被销毁时，删除其中所有的定时器
      ~sort_timer_lst() {
          util_timer* tmp = head;
          while( tmp ) {
              head = tmp->next;
              delete tmp;
              tmp = head;
          }
      }
      
      // 将目标定时器timer添加到链表中
      void add_timer( util_timer* timer ) {
          if( !timer ) {
              return;
          }
          if( !head ) {
              head = tail = timer;
              return; 
          }
          /* 如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，则把该定时器插入链表头部,作为链表新的头节点，
             否则就需要调用重载函数 add_timer(),把它插入链表中合适的位置，以保证链表的升序特性 */
          if( timer->expire < head->expire ) {
              timer->next = head;
              head->prev = timer;
              head = timer;
              return;
          }
          add_timer(timer, head);
      }
      
      /* 当某个定时任务发生变化时，调整对应的定时器在链表中的位置。这个函数只考虑被调整的定时器的
      超时时间延长的情况，即该定时器需要往链表的尾部移动。*/
      void adjust_timer(util_timer* timer)
      {
          if( !timer )  {
              return;
          }
          util_timer* tmp = timer->next;
          // 如果被调整的目标定时器处在链表的尾部，或者该定时器新的超时时间值仍然小于其下一个定时器的超时时间则不用调整
          if( !tmp || ( timer->expire < tmp->expire ) ) {
              return;
          }
          // 如果目标定时器是链表的头节点，则将该定时器从链表中取出并重新插入链表
          if( timer == head ) {
              head = head->next;
              head->prev = NULL;
              timer->next = NULL;
              add_timer( timer, head );
          } else {
              // 如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所在位置后的部分链表中
              timer->prev->next = timer->next;
              timer->next->prev = timer->prev;
              add_timer( timer, timer->next );
          }
      }
      // 将目标定时器 timer 从链表中删除
      void del_timer( util_timer* timer )
      {
          if( !timer ) {
              return;
          }
          // 下面这个条件成立表示链表中只有一个定时器，即目标定时器
          if( ( timer == head ) && ( timer == tail ) ) {
              delete timer;
              head = NULL;
              tail = NULL;
              return;
          }
          /* 如果链表中至少有两个定时器，且目标定时器是链表的头节点，
           则将链表的头节点重置为原头节点的下一个节点，然后删除目标定时器。 */
          if( timer == head ) {
              head = head->next;
              head->prev = NULL;
              delete timer;
              return;
          }
          /* 如果链表中至少有两个定时器，且目标定时器是链表的尾节点，
          则将链表的尾节点重置为原尾节点的前一个节点，然后删除目标定时器。*/
          if( timer == tail ) {
              tail = tail->prev;
              tail->next = NULL;
              delete timer;
              return;
          }
          // 如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器
          timer->prev->next = timer->next;
          timer->next->prev = timer->prev;
          delete timer;
      }
  
      /* SIGALARM 信号每次被触发就在其信号处理函数中执行一次 tick() 函数，以处理链表上到期任务。*/
      void tick() {
          if( !head ) {
              return;
          }
          printf( "timer tick\n" );
          time_t cur = time( NULL );  // 获取当前系统时间
          util_timer* tmp = head;
          // 从头节点开始依次处理每个定时器，直到遇到一个尚未到期的定时器
          while( tmp ) {
              /* 因为每个定时器都使用绝对时间作为超时值，所以可以把定时器的超时值和系统当前时间，
              比较以判断定时器是否到期*/
              if( cur < tmp->expire ) {
                  break;
              }
  
              // 调用定时器的回调函数，以执行定时任务
              tmp->cb_func( tmp->user_data );
              // 执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头节点
              head = tmp->next;
              if( head ) {
                  head->prev = NULL;
              }
              delete tmp;
              tmp = head;
          }
      }
  
  private:
      /* 一个重载的辅助函数，它被公有的 add_timer 函数和 adjust_timer 函数调用
      该函数表示将目标定时器 timer 添加到节点 lst_head 之后的部分链表中 */
      void add_timer(util_timer* timer, util_timer* lst_head)  {
          util_timer* prev = lst_head;
          util_timer* tmp = prev->next;
          /* 遍历 list_head 节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间节点
          并将目标定时器插入该节点之前 */
          while(tmp) {
              if( timer->expire < tmp->expire ) {
                  prev->next = timer;
                  timer->next = tmp;
                  tmp->prev = timer;
                  timer->prev = prev;
                  break;
              }
              prev = tmp;
              tmp = tmp->next;
          }
          /* 如果遍历完 lst_head 节点之后的部分链表，仍未找到超时时间大于目标定时器的超时时间的节点，
             则将目标定时器插入链表尾部，并把它设置为链表新的尾节点。*/
          if( !tmp ) {
              prev->next = timer;
              timer->prev = prev;
              timer->next = NULL;
              tail = timer;
          }
      }
  
  private:
      util_timer* head;   // 头结点
      util_timer* tail;   // 尾结点
  };
  
  #endif
  
  
  ```

- noactive-nonactive_conn.cpp

  ```c++
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>
  #include <assert.h>
  #include <stdio.h>
  #include <signal.h>
  #include <unistd.h>
  #include <errno.h>
  #include <string.h>
  #include <fcntl.h>
  #include <stdlib.h>
  #include <sys/epoll.h>
  #include <pthread.h>
  #include "lst_timer.h"
  
  #define FD_LIMIT 65535
  #define MAX_EVENT_NUMBER 1024
  #define TIMESLOT 5
  
  static int pipefd[2];
  static sort_timer_lst timer_lst;
  static int epollfd = 0;
  
  int setnonblocking( int fd )
  {
      int old_option = fcntl( fd, F_GETFL );
      int new_option = old_option | O_NONBLOCK;
      fcntl( fd, F_SETFL, new_option );
      return old_option;
  }
  
  void addfd( int epollfd, int fd )
  {
      epoll_event event;
      event.data.fd = fd;
      event.events = EPOLLIN | EPOLLET;
      epoll_ctl( epollfd, EPOLL_CTL_ADD, fd, &event );
      setnonblocking( fd );
  }
  
  void sig_handler( int sig )
  {
      int save_errno = errno;
      int msg = sig;
      send( pipefd[1], ( char* )&msg, 1, 0 );
      errno = save_errno;
  }
  
  void addsig( int sig )
  {
      struct sigaction sa;
      memset( &sa, '\0', sizeof( sa ) );
      sa.sa_handler = sig_handler;
      sa.sa_flags |= SA_RESTART;
      sigfillset( &sa.sa_mask );
      assert( sigaction( sig, &sa, NULL ) != -1 );
  }
  
  void timer_handler()
  {
      // 定时处理任务，实际上就是调用tick()函数
      timer_lst.tick();
      // 因为一次 alarm 调用只会引起一次SIGALARM 信号，所以我们要重新定时，以不断触发 SIGALARM信号。
      alarm(TIMESLOT);
  }
  
  // 定时器回调函数，它删除非活动连接socket上的注册事件，并关闭之。
  void cb_func( client_data* user_data )
  {
      epoll_ctl( epollfd, EPOLL_CTL_DEL, user_data->sockfd, 0 );
      assert( user_data );
      close( user_data->sockfd );
      printf( "close fd %d\n", user_data->sockfd );
  }
  
  int main( int argc, char* argv[] ) {
      if( argc <= 1 ) {
          printf( "usage: %s port_number\n", basename( argv[0] ) );
          return 1;
      }
      int port = atoi( argv[1] );
  
      int ret = 0;
      struct sockaddr_in address;
      bzero( &address, sizeof( address ) );
      address.sin_family = AF_INET;
      address.sin_addr.s_addr = INADDR_ANY;
      address.sin_port = htons( port );
  
      int listenfd = socket( PF_INET, SOCK_STREAM, 0 );
      assert( listenfd >= 0 );
  
      ret = bind( listenfd, ( struct sockaddr* )&address, sizeof( address ) );
      assert( ret != -1 );
  
      ret = listen( listenfd, 5 );
      assert( ret != -1 );
  
      epoll_event events[ MAX_EVENT_NUMBER ];
      int epollfd = epoll_create( 5 );
      assert( epollfd != -1 );
      addfd( epollfd, listenfd );
  
      // 创建管道
      ret = socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);
      assert( ret != -1 );
      setnonblocking( pipefd[1] );
      addfd( epollfd, pipefd[0] );
  
      // 设置信号处理函数
      addsig( SIGALRM );
      addsig( SIGTERM );
      bool stop_server = false;
  
      client_data* users = new client_data[FD_LIMIT]; 
      bool timeout = false;
      alarm(TIMESLOT);  // 定时,5秒后产生SIGALARM信号
  
      while( !stop_server )
      {
          int number = epoll_wait( epollfd, events, MAX_EVENT_NUMBER, -1 );
          if ( ( number < 0 ) && ( errno != EINTR ) ) {
              printf( "epoll failure\n" );
              break;
          }
      
          for ( int i = 0; i < number; i++ ) {
              int sockfd = events[i].data.fd;
              if( sockfd == listenfd )
              {
                  struct sockaddr_in client_address;
                  socklen_t client_addrlength = sizeof( client_address );
                  int connfd = accept( listenfd, ( struct sockaddr* )&client_address, &client_addrlength );
                  addfd( epollfd, connfd );
                  users[connfd].address = client_address;
                  users[connfd].sockfd = connfd;
                  
                  // 创建定时器，设置其回调函数与超时时间，然后绑定定时器与用户数据，最后将定时器添加到链表timer_lst中
                  util_timer* timer = new util_timer;
                  timer->user_data = &users[connfd];
                  timer->cb_func = cb_func;
                  time_t cur = time( NULL );
                  timer->expire = cur + 3 * TIMESLOT;
                  users[connfd].timer = timer;
                  timer_lst.add_timer( timer );
              } else if( ( sockfd == pipefd[0] ) && ( events[i].events & EPOLLIN ) ) {
                  // 处理信号
                  int sig;
                  char signals[1024];
                  ret = recv( pipefd[0], signals, sizeof( signals ), 0 );
                  if( ret == -1 ) {
                      continue;
                  } else if( ret == 0 ) {
                      continue;
                  } else  {
                      for( int i = 0; i < ret; ++i ) {
                          switch( signals[i] )  {
                              case SIGALRM:
                              {
                                  // 用timeout变量标记有定时任务需要处理，但不立即处理定时任务
                                  // 这是因为定时任务的优先级不是很高，我们优先处理其他更重要的任务。
                                  timeout = true;
                                  break;
                              }
                              case SIGTERM:
                              {
                                  stop_server = true;
                              }
                          }
                      }
                  }
              }
              else if(  events[i].events & EPOLLIN )
              {
                  memset( users[sockfd].buf, '\0', BUFFER_SIZE );
                  ret = recv( sockfd, users[sockfd].buf, BUFFER_SIZE-1, 0 );
                  printf( "get %d bytes of client data %s from %d\n", ret, users[sockfd].buf, sockfd );
                  util_timer* timer = users[sockfd].timer;
                  if( ret < 0 )
                  {
                      // 如果发生读错误，则关闭连接，并移除其对应的定时器
                      if( errno != EAGAIN )
                      {
                          cb_func( &users[sockfd] );
                          if( timer )
                          {
                              timer_lst.del_timer( timer );
                          }
                      }
                  }
                  else if( ret == 0 )
                  {
                      // 如果对方已经关闭连接，则我们也关闭连接，并移除对应的定时器。
                      cb_func( &users[sockfd] );
                      if( timer )
                      {
                          timer_lst.del_timer( timer );
                      }
                  }
                  else
                  {
                      // 如果某个客户端上有数据可读，则我们要调整该连接对应的定时器，以延迟该连接被关闭的时间。
                      if( timer ) {
                          time_t cur = time( NULL );
                          timer->expire = cur + 3 * TIMESLOT;
                          printf( "adjust timer once\n" );
                          timer_lst.adjust_timer( timer );
                      }
                  }
              }
             
          }
  
          // 最后处理定时事件，因为I/O事件有更高的优先级。当然，这样做将导致定时任务不能精准的按照预定的时间执行。
          if( timeout ) {
              timer_handler();
              timeout = false;
          }
      }
  
      close( listenfd );
      close( pipefd[1] );
      close( pipefd[0] );
      delete [] users;
      return 0;
  }
  
  
  ```

- 压力测试

Webbench 是 Linux 上一款知名的、优秀的 web 性能压力测试工具。它是由Lionbridge公司开发。

> 测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。
>
> 展示服务器的两项内容：每秒钟响应请求数和每秒钟传输数据量

基本原理：Webbench 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的结果通过pipe 告诉父进程，父进程做最终的统计结果。

测试示例

```c++
webbench -c 1000 -t 30 http://192.168.110.129:10000/index.html
参数：
	-c 表示客户端数
	-t 表示时间

```