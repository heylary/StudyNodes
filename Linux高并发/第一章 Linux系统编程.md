# 第一章 Linux系统编程

## 1. GCC



### 1.1 GCC开发环境搭建1 

GCC 原名为 GNU C语言编译器（GNU C Compiler）

- 安装命令 sudo apt install gcc g++ （版本 > 4.8.5）

- 查看版本 gcc/g++ -v/--versio
- 

### 1.2 GCC工作流程

![image-20230223150309392](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223150309392.png)


### 1.3 GCC和G++的区别

gcc 和 g++都是GNU(组织)的一个编译器。

- 误区一：gcc 只能编译 c 代码，g++ 只能编译 c++ 代码。**两者都可以编译**，请注意：  
  - 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序 
  - 后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些 
  -  编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统 一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只 能用 g++ 似的
  - **如果是c++程序使用gcc完成编译，g++完成链接**，因为gcc命令不能自动和C++程序使用的库联接

- 误区二：gcc 不会定义 __cplusplus 宏，而 g++ 会 
  -  实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释 
- 误区三：编译只能用 gcc，链接只能用 g++ 
  -  严格来说，这句话不算错误，但是它混淆了概念，应该这样说：**编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++**。
  -   gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。 
  - **但在编译阶段，g++ 会自动调用 gcc，二者等价**
  - 

### 1.4 GCC常用参数

![image-20230223151229040](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223151229040.png)

![image-20230223151253516](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223151253516.png)

## 2. 静态库的制作⭐

### 2.1 什么是库

库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用 者一些可以直接拿来用的变量、函数或类。

库文件有两种，**静态库和动态库（共享库）**区别是：

- 静态库在程序的链接阶段被复制 到了程序中；
- 动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。



### 2.2 静态库的制作

**（1）命名规则：**

 ◆ Linux : **libxxx.a** 

​			lib : 前缀（固定） 

​			xxx : 库的名字，自己起 

​			.a : 后缀（固定） 

◆ Windows : libxxx.li

**（2）静态库的制作：**

◆ gcc 获得 .o 文件 

◆ 将 .o 文件打包，使用 ar 工具（archive） 

​			**ar rcs libxxx.a xxx.o xxx.o** 

​				r – 将文件插入备存文件中 

​				c – 建立备存文件 

​				s – 索引



## 3. 动态库的制作⭐

### 3.1 动态库的制作

**（1）命名规则：** 

​		◆ Linux : **libxxx.so** 

​					lib : 前缀（固定） 

​					xxx : 库的名字，自己起 

​					.so : 后缀（固定） 在Linux下是一个可执行文件 

​		◆ Windows : libxxx.dll

**（2）动态库的制作：** 

​		◆ gcc 得到 .o 文件，得到和位置无关的代码 

​				**gcc -c –fpic/-fPIC a.c b.c** 

​		◆ gcc 得到动态库 

​			**gcc -shared a.o b.o -o libcalc.so**



### 3.2 工作原理 

- 静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中

- 动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中

- 程序启动之后，动态库会被动态加载到内存中，通过 ldd （list dynamic  dependencies）命令检查动态库依赖关系

- 如何定位共享库文件呢？

  - 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路 径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是 由ld-linux.so来完成的，它先后搜索elf文件的 DT_RPATH段 ——> 环境变量 LD_LIBRARY_PATH ——> /etc/ld.so.cache文件列表 ——> /lib/，/usr/lib 目录找到库文件后将其载入内存

  

## 4. 静态库和动态库的对比⭐

![image-20230223153255941](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223153255941.png)

静态库、动态库区别来自链接阶段如何处理，链接成 可执行程序。分别称为静态链接方式和动态链接方式。

### 4.1 静态库制作过程

![image-20230223153333086](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223153333086.png)

### 4.2 动态库制作过程

![image-20230223153351334](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223153351334.png)



### 4.3 静态库的优缺点

![image-20230223153543124](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223153543124.png)

**（1）优点**

- 静态库被打包到应用程序中加载速度快

- 发布程序无需提供静态库，移植方便

**（2）缺点**

- 消耗系统资源，浪费内存 
-  更新、部署、发布麻烦

### 4.4 动态库的优缺点

![image-20230223153635978](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223153635978.png)

**（1）优点**

- 可以实现进程间资源共享（共享库）
- 更新、部署、发布简单 
- 可以控制何时加载动态库

**（2）缺点**

- 加载速度比静态库慢 
- 发布程序时需要提供依赖的动态库
- 

## 5. Makefile

### 5.1 什么是Makefile

Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编 译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就 像一个 Shell 脚本一样，也可以执行操作系统的命令。

Makefile 带来的好处就是“**自动化编译”** ，一旦写好，只需要一个 make 命令，整 个工程完全自动编译，极大的提高了软件开发的效率



### 5.2 Makefile文件命名和规则

**（1）文件命名**

​			makefile 或者 Makefile

**（2）Makefile规则**

​			一个 Makefile 文件中可以有一个或者多个规则

![image-20230223154549898](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223154549898.png)

### 5.3 工作原理

命令在执行之前，需要先检查规则中的依赖是否存在 

- 如果存在，执行命令 
- 如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的， 如果找到了，则执行该规则中的命令

检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间

- 如果依赖的时间比目标的时间晚，需要重新生成目标 

- 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被 执行

### 5.4 变量

**（1）自定义变量**

​	变量名=变量值 var=hello

**（2）预定义变量**

- AR : 归档维护程序的名称，默认值为 ar
-  CC : C 编译器的名称，默认值为 cc 
- CXX : C++ 编译器的名称，默认值为 g++ 
- $@ : 目标的完整名称
-  $< : 第一个依赖文件的名称 
- $^ : 所有的依赖文件

**（3）获取变量的值**

$(变量名) $(var)

（4）例子

```c
app:main.c a.c b.c

	gcc -c main.c a.c b.c
```

\#自动变量只能在规则的命令中使用 

```c
	app:main.c a.c b.c

​		$(CC) -c $^ -o $@
```



### 5.5 模式匹配

```
add.o:add.c
	gcc -c add.c
div.o:div.c
	gcc -c div.c
sub.o:sub.c
	gcc -c sub.c
mult.o:mult.c
	gcc -c mult.c
main.o:main.c
	gcc -c main.c

```

![image-20230223155453341](D:\WorkData\MarkdownData\Linux高并发\assets\image-20230223155453341.png)

##  6. GDB调试

GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环 境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。

一般来说，GDB 主要帮助你完成下面四个方面的功能：

1. 启动程序，可以按照自定义的要求随心所欲的运行程序 
2. 可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）
3. 当程序被停住时，可以检查此时程序中所发生的事 
4. 可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG

```c
 gcc -g -Wall program.c -o program 
```

◼ `-g` 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机 器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调 试时必须保证 gdb 能找到源文件

### 6.1 启动退出、查看代码

- 启动和退出
  - gdb 可执行程序
  - quit
- 给程序设置参数/获取设置参数
  - set args 10 20
  - show args
- GDB 使用帮助
  - help
- 查看当前文件代码
  - list/l （从默认位置显示)
  - list/l 行号 （从指定的行显示）
  - list/l 函数名（从指定的函数显示
- 查看非当前文件代码
  - list/l 文件名:行号
  - list/l 文件名:函数

-  设置显示的行数
  - show list/listsize
  - set list/listsize 行数

### 6.2 断点操作

- 设置断点
  - b/break 行号
  - b/break 函数名
  - b/break 文件名:行号
  - b/break 文件名:函数
- 查看断点
  - i/info b/break
- 删除断点
  - d/del/delete 断点编号
- 设置断点无效
  - dis/disable 断点编号
- 设置断点生效
  - ena/enable 断点编号
- 设置条件断点（一般用在循环的位置）
  - b/break 10 if i==5

### 6.3 调试命令

- 运行GDB程序
  - start（程序停在第一行）
  - run（遇到断点才停）
- 继续运行，到下一个断点停
  - c/continue
- 向下执行一行代码（不会进入函数体）
  - n/next
- 变量操作
  - p/print 变量名（打印变量值）
  - ptype 变量名（打印变量类型）
- 向下单步调试（遇到函数进入函数体
  - s/step
  - finish（跳出函数体）
- 自动变量操作
  - display 变量名（自动打印指定变量的值）
  - i/info display
  - undisplay 编号
-  其它操作
  - set var 变量名=变量值 （循环中用的较多）
  - until （跳出循环）







